`timescale 1 ns / 1 ps

module pwm_ip_v1_0_S00_AXI #
(
    parameter integer C_S_AXI_DATA_WIDTH = 32,
    parameter integer C_S_AXI_ADDR_WIDTH = 4
)
(
    // 4 registers exposed to top-level (PWM0 & PWM1)
    output reg [31:0] slv_reg0,
    output reg [31:0] slv_reg1,
    output reg [31:0] slv_reg2,
    output reg [31:0] slv_reg3,

    // AXI signals
    input  wire                          S_AXI_ACLK,
    input  wire                          S_AXI_ARESETN,
    input  wire [C_S_AXI_ADDR_WIDTH-1:0] S_AXI_AWADDR,
    input  wire                          S_AXI_AWVALID,
    output wire                          S_AXI_AWREADY,
    input  wire [C_S_AXI_DATA_WIDTH-1:0] S_AXI_WDATA,
    input  wire [(C_S_AXI_DATA_WIDTH/8)-1:0] S_AXI_WSTRB,
    input  wire                          S_AXI_WVALID,
    output wire                          S_AXI_WREADY,
    output wire [1:0]                    S_AXI_BRESP,
    output wire                          S_AXI_BVALID,
    input  wire                          S_AXI_BREADY,
    input  wire [C_S_AXI_ADDR_WIDTH-1:0] S_AXI_ARADDR,
    input  wire                          S_AXI_ARVALID,
    output wire                          S_AXI_ARREADY,
    output wire [C_S_AXI_DATA_WIDTH-1:0] S_AXI_RDATA,
    output wire [1:0]                    S_AXI_RRESP,
    output wire                          S_AXI_RVALID,
    input  wire                          S_AXI_RREADY
);

    // ------------------------------------------------
    // Internal AXI registers
    // ------------------------------------------------
    reg  axi_awready;
    reg  axi_wready;
    reg  axi_bvalid;
    reg  [1:0] axi_bresp;

    reg  axi_arready;
    reg  axi_rvalid;
    reg  [1:0] axi_rresp;
    reg  [C_S_AXI_DATA_WIDTH-1:0] axi_rdata;

    reg  [C_S_AXI_ADDR_WIDTH-1:0] axi_awaddr;
    reg  [C_S_AXI_ADDR_WIDTH-1:0] axi_araddr;

    assign S_AXI_AWREADY = axi_awready;
    assign S_AXI_WREADY  = axi_wready;
    assign S_AXI_BVALID  = axi_bvalid;
    assign S_AXI_BRESP   = axi_bresp;
    assign S_AXI_ARREADY = axi_arready;
    assign S_AXI_RVALID  = axi_rvalid;
    assign S_AXI_RRESP   = axi_rresp;
    assign S_AXI_RDATA   = axi_rdata;

    // ------------------------------------------------
    // Address decode bits
    // ------------------------------------------------
    localparam ADDR_LSB = (C_S_AXI_DATA_WIDTH/32) + 1;
    localparam OPT_MEM_ADDR_BITS = 1;

    wire slv_reg_wren;
    wire slv_reg_rden;

    // ------------------------------------------------
    // Write Address Channel
    // ------------------------------------------------
    always @(posedge S_AXI_ACLK)
    begin
        if (!S_AXI_ARESETN)
            axi_awready <= 1'b0;
        else if (!axi_awready && S_AXI_AWVALID && S_AXI_WVALID)
            axi_awready <= 1'b1;
        else
            axi_awready <= 1'b0;
    end

    always @(posedge S_AXI_ACLK)
    begin
        if (!S_AXI_ARESETN)
            axi_awaddr <= 0;
        else if (!axi_awready && S_AXI_AWVALID && S_AXI_WVALID)
            axi_awaddr <= S_AXI_AWADDR;
    end

    // ------------------------------------------------
    // Write Data Channel
    // ------------------------------------------------
    always @(posedge S_AXI_ACLK)
    begin
        if (!S_AXI_ARESETN)
            axi_wready <= 1'b0;
        else if (!axi_wready && S_AXI_WVALID && S_AXI_AWVALID)
            axi_wready <= 1'b1;
        else
            axi_wready <= 1'b0;
    end

    assign slv_reg_wren = axi_wready & S_AXI_WVALID & axi_awready & S_AXI_AWVALID;

    always @(posedge S_AXI_ACLK)
    begin
        if (!S_AXI_ARESETN) begin
            slv_reg0 <= 0;
            slv_reg1 <= 0;
            slv_reg2 <= 0;
            slv_reg3 <= 0;
        end else if (slv_reg_wren) begin
            case (axi_awaddr[ADDR_LSB+OPT_MEM_ADDR_BITS:ADDR_LSB])
                2'h0: slv_reg0 <= S_AXI_WDATA;
                2'h1: slv_reg1 <= S_AXI_WDATA;
                2'h2: slv_reg2 <= S_AXI_WDATA;
                2'h3: slv_reg3 <= S_AXI_WDATA;
            endcase
        end
    end

    // ------------------------------------------------
    // Write Response
    // ------------------------------------------------
    always @(posedge S_AXI_ACLK)
    begin
        if (!S_AXI_ARESETN) begin
            axi_bvalid <= 1'b0;
            axi_bresp  <= 2'b00;
        end else if (axi_awready && S_AXI_AWVALID && axi_wready && S_AXI_WVALID && !axi_bvalid) begin
            axi_bvalid <= 1'b1;
            axi_bresp  <= 2'b00;
        end else if (S_AXI_BREADY && axi_bvalid)
            axi_bvalid <= 1'b0;
    end

    // ------------------------------------------------
    // Read Address Channel
    // ------------------------------------------------
    always @(posedge S_AXI_ACLK)
    begin
        if (!S_AXI_ARESETN)
            axi_arready <= 1'b0;
        else if (!axi_arready && S_AXI_ARVALID)
            axi_arready <= 1'b1;
        else
            axi_arready <= 1'b0;
    end

    always @(posedge S_AXI_ACLK)
    begin
        if (!S_AXI_ARESETN)
            axi_araddr <= 0;
        else if (!axi_arready && S_AXI_ARVALID)
            axi_araddr <= S_AXI_ARADDR;
    end

    // ------------------------------------------------
    // Read Data Channel
    // ------------------------------------------------
    assign slv_reg_rden = axi_arready & S_AXI_ARVALID & ~axi_rvalid;

    always @(*)
    begin
        case (axi_araddr[ADDR_LSB+OPT_MEM_ADDR_BITS:ADDR_LSB])
            2'h0: axi_rdata = slv_reg0;
            2'h1: axi_rdata = slv_reg1;
            2'h2: axi_rdata = slv_reg2;
            2'h3: axi_rdata = slv_reg3;
            default: axi_rdata = 0;
        endcase
    end

    always @(posedge S_AXI_ACLK)
    begin
        if (!S_AXI_ARESETN) begin
            axi_rvalid <= 1'b0;
            axi_rresp  <= 2'b00;
        end else if (slv_reg_rden) begin
            axi_rvalid <= 1'b1;
            axi_rresp  <= 2'b00;
        end else if (axi_rvalid && S_AXI_RREADY)
            axi_rvalid <= 1'b0;
    end

endmodule
